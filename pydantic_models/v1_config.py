# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-09-07T11:18:21+00:00

from __future__ import annotations

from enum import Enum
from ipaddress import IPv4Address, IPv6Address
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, confloat, conint, constr



class SwitchPort(BaseModel):
    id: str = Field(..., description='The port id')
    pvid: str = Field(..., description='The primary vlan id')
    cpu_port: bool = Field(
        ..., description='True if this port is connected directly to the CPU'
    )


class SwitchVlan(BaseModel):
    id: str = Field(..., description='The vlan id')


class DeviceSettings(BaseModel):
    pass


class Type(Enum):
    NIC = 'NIC'
    VLAN = 'VLAN'
    WIFI = 'WIFI'
    OPENVPN = 'OPENVPN'
    WIREGUARD = 'WIREGUARD'
    WWAN = 'WWAN'


class ConfigType(Enum):
    ADDRESSED = 'ADDRESSED'
    BRIDGED = 'BRIDGED'


class V4ConfigType(Enum):
    STATIC = 'STATIC'
    DHCP = 'DHCP'
    DISABLED = 'DISABLED'


class V6ConfigType(Enum):
    DHCP = 'DHCP'
    SLAAC = 'SLAAC'
    ASSIGN = 'ASSIGN'
    STATIC = 'STATIC'
    DISABLED = 'DISABLED'


class DhcpOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: bool = Field(..., description='True if option is enabled')
    description: Optional[str] = Field(
        None, description='Admin-supplied human readable description'
    )
    value: str = Field(..., description='The dnsmasq option value')


class WirelessEncryption(Enum):
    NONE = 'NONE'
    WPA1 = 'WPA1'
    WPA12 = 'WPA12'
    WPA2 = 'WPA2'


class WirelessMode(Enum):
    AP = 'AP'
    CLIENT = 'CLIENT'


class WireguardEditMode(Enum):
    PASTE = 'PASTE'
    MANUAL = 'MANUAL'


class WireguardType(Enum):
    ROAMING = 'ROAMING'
    TUNNEL = 'TUNNEL'


class SimAuth(Enum):
    NONE = 'NONE'
    PAP = 'PAP'
    CHAP = 'CHAP'
    BOTH = 'BOTH'


class SimMode(Enum):
    ALL = 'ALL'
    LTE = 'LTE'
    UMTS = 'UMTS'
    GSM = 'GSM'
    CDMA = 'CDMA'
    TDSCDMA = 'TDSCDMA'


class SimPdptype(Enum):
    IPV4 = 'IPV4'
    IPV6 = 'IPV6'
    IPV4V6 = 'IPV4V6'


class EthDuplex(Enum):
    half = 'half'
    full = 'full'


class Encoding(Enum):
    base64 = 'base64'


class FileSettings(BaseModel):
    encoding: Encoding = Field(..., description='The encoding of the file')
    contents: str = Field(..., description='The (encoded) contents of the file')
    path: Optional[str] = Field(
        None, description='The path of the file, not useds in some cases'
    )
    operation: Optional[str] = Field(
        None,
        description='The sync-settings operation that needs to take place if this file changes',
    )


class Ipv4Alias(BaseModel):
    pass


class Ipv6Alias(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    v6Address: IPv6Address = Field(..., description='The IPv6 static address')
    v6Prefix: conint(ge=1, le=128) = Field(..., description='The IPv6 static prefix')


class WireguardAddress(BaseModel):
    pass


class WireguardAllowedIp(BaseModel):
    pass


class WireguardPeer(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    publicKey: str = Field(..., description="The wireguard peer's public key")
    allowedIps: List[WireguardAllowedIp] = Field(
        ..., description="List of peer's allowed IP addresses"
    )
    host: Optional[str] = Field(
        None, description="The wireguard server's IP or hostname"
    )
    port: Optional[int] = Field(None, description="The wireguard server's port")
    presharedKey: Optional[str] = Field(
        None, description="The wireguard peer's pre-shared key"
    )
    keepalive: Optional[int] = Field(
        None,
        description='The wireguard persistent keepalive interval (seconds) for this peer',
    )
    routeAllowedIps: Optional[bool] = Field(
        None, description='True if packets from this wireguard peer should be routed'
    )


class Track(BaseModel):
    pass


class Logging(BaseModel):
    type: Optional[str] = Field(None, description='Type of log file')
    file: Optional[str] = Field(None, description='Path to log file')
    size: Optional[int] = Field(None, description='Size of log file in Kib')
    remote: Optional[bool] = Field(None, description='Is log file located remotely')
    ip: Optional[str] = Field(None, description='IP of remote log')
    port: Optional[int] = Field(None, description='Port of remote log')
    protocol: Optional[str] = Field(
        None, description='Protocol for remote logging (either tcp/udp)'
    )
    prefix: Optional[str] = Field(None, description='Logging Prefix')


class SetupWizardSettings(BaseModel):
    completed: Optional[bool] = Field(
        None, description='True if the setup wizard has been completed'
    )
    lastStep: Optional[str] = Field(
        None,
        description='The last completed step of the wizard (used by the wizard to store progress for restore)',
    )


class TimeZoneSettings(BaseModel):
    displayName: Optional[str] = Field(
        None, description='The display name of the timezone (in the UI)'
    )
    value: Optional[str] = Field(
        None, description='The actual value of the timezone (used by OS)'
    )


class CloudSettings(BaseModel):
    enabled: Optional[bool] = Field(None, description='Enable cloud connection')
    supportAccessEnabled: Optional[bool] = Field(
        None, description='Enable remote support team access'
    )
    cloudServers: Optional[List[str]] = Field(None, description='Remote cloud servers')


class AutoSettings(BaseModel):
    enabled: Optional[bool] = Field(None, description='Enable auto schedule')
    dayOfWeek: Optional[conint(ge=0, le=6)] = Field(
        None,
        description='The day of week to auto run process (0-6) (0 is Sunday 6 is Saturday)',
    )
    hourOfDay: Optional[conint(ge=0, le=23)] = Field(
        None, description='The hour of day to auto run process (0-23)'
    )
    minuteOfHour: Optional[conint(ge=0, le=59)] = Field(
        None, description='The minute of hour to auto run process (0-59)'
    )


class Type1(Enum):
    TEXT = 'TEXT'
    EVENTS = 'EVENTS'
    CATEGORIES = 'CATEGORIES'
    SERIES = 'SERIES'
    CATEGORIES_SERIES = 'CATEGORIES_SERIES'


class Operator(Enum):
    EQ = 'EQ'
    NE = 'NE'
    GT = 'GT'
    LT = 'LT'
    GE = 'GE'
    LE = 'LE'
    LIKE = 'LIKE'
    NOT_LIKE = 'NOT_LIKE'
    IS = 'IS'
    IS_NOT = 'IS_NOT'
    IN = 'IN'
    NOT_IN = 'NOT_IN'


class ReportQueryText(BaseModel):
    columns: List[str] = Field(
        ..., description='The columns to query for text-based reports'
    )


class ReportQuerySeries(BaseModel):
    columns: Optional[List[str]] = Field(
        None,
        description='The columns to query for series reports. If null, the columns will be queried dynamically using categoriesGroupColumn, categoriesAggregation, and categoriesLimit. If unspecified the categories query will be used to determine columns',
    )
    timeIntervalSeconds: Optional[conint(ge=1)] = Field(
        None,
        description='The time granularity of series report in seconds (1 = 1 datapoint/second, 60 = 1 datapoint/minute). Beware often 1 second is ideal and the UI can aggregate multiple datapoints using dataGroupingApproximation. 60 if unspecified.',
    )


class ReportQueryCategories(BaseModel):
    groupColumn: str = Field(
        ...,
        description='This is the column to group by in categories reports. This is the X in Top X category reports.',
    )
    aggregationFunction: str = Field(
        ...,
        description='This is the aggregation function for the categoriesGroupColumn. This is usually count(*) or sum(*).',
    )
    aggregationValue: str = Field(
        ...,
        description='This is the value to be aggregated. For count(*) this can be "*".',
    )
    limit: Optional[int] = Field(
        None,
        description="This is the limit of the number of results for categories. 10 for Top 10. Beware this is normally null (no limit) as the rendering will properly show the sum of the long tail of values as 'Others'.",
    )
    orderByColumn: Optional[conint(ge=1, le=2)] = Field(
        None,
        description='This defines the column to use to order the results. 1 means categoriesOrderByColumn, 2 means the aggregation by value. 2 if unspecified.',
    )
    orderAsc: Optional[bool] = Field(
        None,
        description='If true the results will be order by ASC, if false or unspecified the results will be order by DESC.',
    )


class ReportQueryEvents(BaseModel):
    orderByColumn: Optional[str] = Field(
        None,
        description="The column name to order by. If unspecified the results will be ordered by 'time_stamp'",
    )
    orderAsc: Optional[bool] = Field(
        None,
        description='If true the results will be order by ASC, if false or unspecified the results will be order by DESC.',
    )


class Type3(Enum):
    spline = 'spline'
    line = 'line'
    areaspline = 'areaspline'
    area = 'area'
    pie = 'pie'
    column = 'column'


class Stacking(Enum):
    none = 'none'
    normal = 'normal'
    percent = 'percent'


class DashStyle(Enum):
    Solid = 'Solid'
    ShortDash = 'ShortDash'
    ShortDashDot = 'ShortDashDot'
    ShortDashDotDot = 'ShortDashDotDot'
    Dot = 'Dot'
    Dash = 'Dash'
    LongDash = 'LongDash'
    LongDashDot = 'LongDashDot'
    LongDashDotDot = 'LongDashDotDot'


class DataGroupingApproximation(Enum):
    average = 'average'
    high = 'high'
    low = 'low'
    sum = 'sum'


class ReportRendering(BaseModel):
    type: Optional[Type3] = Field(None, description='The chart type')
    units: Optional[str] = Field(None, description='The units of the report')
    colors: Optional[List[str]] = Field(None, description='The color pallette')
    stacking: Optional[Stacking] = Field(
        None,
        description='Stacking type. In case of Time Series data, multiple series can be stacked.',
    )
    lineWidth: Optional[confloat(ge=0.0, le=5.0, multiple_of=0.5)] = Field(
        None, description='The line/area chart line width (px)'
    )
    borderWidth: Optional[confloat(ge=0.0, le=5.0, multiple_of=0.5)] = Field(
        None, description='The border width separating pie slices (px)'
    )
    topAreaOpacity: Optional[confloat(ge=0.0, le=1.0, multiple_of=0.1)] = Field(
        None, description='The opacity of top part for an area chart'
    )
    bottomAreaOpacity: Optional[confloat(ge=0.0, le=1.0, multiple_of=0.1)] = Field(
        None, description='The opacity of bottom part for an area chart'
    )
    dashStyle: Optional[DashStyle] = Field(
        None, description='The line/area charts line dashing style'
    )
    dataGroupingEnabled: Optional[bool] = Field(
        None, description='True to enable data grouping for Time Series'
    )
    dataGroupingApproximation: Optional[DataGroupingApproximation] = Field(
        None, description='The approximation method for data grouping'
    )
    dataGroupingFactor: Optional[confloat(ge=10.0, le=50.0, multiple_of=10.0)] = Field(
        None,
        description='The data grouping size. Higher value results in bigger number of points being grouped. (px)',
    )
    donutInnerSize: Optional[confloat(ge=0.0, le=90.0, multiple_of=10.0)] = Field(
        None,
        description='Inner ring percent size of a donut (which is a pie based chart). 0 is equivalent to a normal pie',
    )
    field_3dEnabled: Optional[bool] = Field(
        None,
        alias='3dEnabled',
        description='Enable or disable the 3D options for the pie/donut charts',
    )
    field_3dAlpha: Optional[confloat(ge=0.0, le=100.0, multiple_of=5.0)] = Field(
        None, alias='3dAlpha', description='Adjusts the 3D aspect of the pie chart'
    )
    field_3dDepth: Optional[confloat(ge=10.0, le=50.0, multiple_of=5.0)] = Field(
        None, alias='3dDepth', description='Adjusts the 3D depth of the pie chart'
    )
    slicesNumber: Optional[confloat(ge=2.0, le=15.0, multiple_of=1.0)] = Field(
        None, description='The number of pie slices to show on pie charts by default'
    )
    defaultColumns: Optional[List[str]] = Field(
        None,
        description='The the default column names to display for event list reports',
    )
    columnRenames: Optional[Dict[str, Any]] = Field(
        None, description='A string->string map for database name to display name'
    )
    textString: Optional[str] = Field(
        None, description='The user-defined string for a text report'
    )


class Type4(Enum):
    JUMP = 'JUMP'
    GOTO = 'GOTO'
    ACCEPT = 'ACCEPT'
    RETURN = 'RETURN'
    REJECT = 'REJECT'
    DROP = 'DROP'


class Family(Enum):
    inet = 'inet'
    ip = 'ip'
    ip6 = 'ip6'
    arp = 'arp'
    bridge = 'bridge'
    netdev = 'netdev'
    ip_ip6 = 'ip,ip6'
    ip_ip6_inet = 'ip,ip6,inet'


class ChainType(Enum):
    filter = 'filter'
    route = 'route'
    nat = 'nat'


class Hook(Enum):
    prerouting = 'prerouting'
    input = 'input'
    forward = 'forward'
    output = 'output'
    postrouting = 'postrouting'
    ingress = 'ingress'


class Type6(Enum):
    JUMP = 'JUMP'
    GOTO = 'GOTO'
    ACCEPT = 'ACCEPT'
    RETURN = 'RETURN'
    SNAT = 'SNAT'
    MASQUERADE = 'MASQUERADE'


class PortForwardTable(RootModel[Any]):
    root: Any


class Type7(Enum):
    JUMP = 'JUMP'
    GOTO = 'GOTO'
    ACCEPT = 'ACCEPT'
    RETURN = 'RETURN'
    REJECT = 'REJECT'
    DROP = 'DROP'
    DNAT = 'DNAT'
    SNAT = 'SNAT'
    MASQUERADE = 'MASQUERADE'
    SET_PRIORITY = 'SET_PRIORITY'
    LIMIT_EXCEED_ACTION = 'LIMIT_EXCEED_ACTION'
    WAN_POLICY = 'WAN_POLICY'


class RuleAction(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    type: Optional[Type7] = None
    chain: Optional[str] = None
    dnat_address: Optional[str] = None
    dnat_port: Optional[int] = None
    snat_address: Optional[str] = None
    priority: Optional[conint(ge=1, le=21)] = None
    destination: Optional[int] = None
    policy: Optional[int] = None
    limit_exceed_action: Optional[str] = None
    return_action: Optional[bool] = Field(
        None,
        description='True if an additional RETURN action is to be added ahead of SET_PRIORITY',
    )


class Type8(Enum):
    JUMP = 'JUMP'
    GOTO = 'GOTO'
    ACCEPT = 'ACCEPT'
    RETURN = 'RETURN'
    DROP = 'DROP'
    SET_PRIORITY = 'SET_PRIORITY'
    LIMIT_EXCEED_ACTION = 'LIMIT_EXCEED_ACTION'


class Action3(RuleAction):
    type: Optional[Type8] = None


class Op(Enum):
    field__ = '=='
    field___1 = '!='


class RuleCondition1(BaseModel):
    op: Optional[Op] = None


class Value(Enum):
    unspec = 'unspec'
    unicast = 'unicast'
    local = 'local'
    broadcast = 'broadcast'
    anycast = 'anycast'
    multicast = 'multicast'
    blackhole = 'blackhole'
    unreachable = 'unreachable'
    prohibit = 'prohibit'


class Type9(Enum):
    IP_PROTOCOL = 'IP_PROTOCOL'
    SOURCE_ADDRESS = 'SOURCE_ADDRESS'
    SOURCE_ADDRESS_TYPE = 'SOURCE_ADDRESS_TYPE'
    DESTINATION_ADDRESS = 'DESTINATION_ADDRESS'
    DESTINATION_ADDRESS_TYPE = 'DESTINATION_ADDRESS_TYPE'
    CLIENT_ADDRESS = 'CLIENT_ADDRESS'
    SERVER_ADDRESS = 'SERVER_ADDRESS'
    LOCAL_ADDRESS = 'LOCAL_ADDRESS'
    REMOTE_ADDRESS = 'REMOTE_ADDRESS'
    CLIENT_ADDRESS_V6 = 'CLIENT_ADDRESS_V6'
    SERVER_ADDRESS_V6 = 'SERVER_ADDRESS_V6'
    LOCAL_ADDRESS_V6 = 'LOCAL_ADDRESS_V6'
    REMOTE_ADDRESS_V6 = 'REMOTE_ADDRESS_V6'
    SOURCE_ADDRESS_V6 = 'SOURCE_ADDRESS_V6'
    DESTINATION_ADDRESS_V6 = 'DESTINATION_ADDRESS_V6'
    SOURCE_PORT = 'SOURCE_PORT'
    DESTINATION_PORT = 'DESTINATION_PORT'
    CLIENT_PORT = 'CLIENT_PORT'
    SERVER_PORT = 'SERVER_PORT'
    LOCAL_PORT = 'LOCAL_PORT'
    REMOTE_PORT = 'REMOTE_PORT'
    CLIENT_INTERFACE_ZONE = 'CLIENT_INTERFACE_ZONE'
    SERVER_INTERFACE_ZONE = 'SERVER_INTERFACE_ZONE'
    SOURCE_INTERFACE_ZONE = 'SOURCE_INTERFACE_ZONE'
    DESTINATION_INTERFACE_ZONE = 'DESTINATION_INTERFACE_ZONE'
    CLIENT_INTERFACE_TYPE = 'CLIENT_INTERFACE_TYPE'
    SERVER_INTERFACE_TYPE = 'SERVER_INTERFACE_TYPE'
    SOURCE_INTERFACE_TYPE = 'SOURCE_INTERFACE_TYPE'
    DESTINATION_INTERFACE_TYPE = 'DESTINATION_INTERFACE_TYPE'
    SOURCE_INTERFACE_NAME = 'SOURCE_INTERFACE_NAME'
    DESTINATION_INTERFACE_NAME = 'DESTINATION_INTERFACE_NAME'
    CLIENT_HOSTNAME = 'CLIENT_HOSTNAME'
    SERVER_HOSTNAME = 'SERVER_HOSTNAME'
    LOCAL_HOSTNAME = 'LOCAL_HOSTNAME'
    REMOTE_HOSTNAME = 'REMOTE_HOSTNAME'
    CLIENT_USERNAME = 'CLIENT_USERNAME'
    CLIENT_DNS_HINT = 'CLIENT_DNS_HINT'
    SERVER_USERNAME = 'SERVER_USERNAME'
    SERVER_DNS_HINT = 'SERVER_DNS_HINT'
    LOCAL_USERNAME = 'LOCAL_USERNAME'
    REMOTE_USERNAME = 'REMOTE_USERNAME'
    APPLICATION_ID = 'APPLICATION_ID'
    APPLICATION_NAME = 'APPLICATION_NAME'
    APPLICATION_PROTOCHAIN = 'APPLICATION_PROTOCHAIN'
    APPLICATION_DETAIL = 'APPLICATION_DETAIL'
    APPLICATION_CATEGORY = 'APPLICATION_CATEGORY'
    APPLICATION_ID_INFERRED = 'APPLICATION_ID_INFERRED'
    APPLICATION_NAME_INFERRED = 'APPLICATION_NAME_INFERRED'
    APPLICATION_CONFIDENCE_INFERRED = 'APPLICATION_CONFIDENCE_INFERRED'
    APPLICATION_PROTOCHAIN_INFERRED = 'APPLICATION_PROTOCHAIN_INFERRED'
    APPLICATION_PRODUCTIVITY_INFERRED = 'APPLICATION_PRODUCTIVITY_INFERRED'
    APPLICATION_RISK_INFERRED = 'APPLICATION_RISK_INFERRED'
    APPLICATION_CATEGORY_INFERRED = 'APPLICATION_CATEGORY_INFERRED'
    CERT_SUBJECT_CN = 'CERT_SUBJECT_CN'
    CERT_SUBJECT_SN = 'CERT_SUBJECT_SN'
    CERT_SUBJECT_C = 'CERT_SUBJECT_C'
    CERT_SUBJECT_O = 'CERT_SUBJECT_O'
    CERT_SUBJECT_OU = 'CERT_SUBJECT_OU'
    CERT_SUBJECT_L = 'CERT_SUBJECT_L'
    CERT_SUBJECT_P = 'CERT_SUBJECT_P'
    CERT_SUBJECT_SA = 'CERT_SUBJECT_SA'
    CERT_SUBJECT_PC = 'CERT_SUBJECT_PC'
    CERT_SUBJECT_SAN = 'CERT_SUBJECT_SAN'
    CERT_SUBJECT_DNS = 'CERT_SUBJECT_DNS'
    CERT_ISSUER_CN = 'CERT_ISSUER_CN'
    CERT_ISSUER_SN = 'CERT_ISSUER_SN'
    CERT_ISSUER_C = 'CERT_ISSUER_C'
    CERT_ISSUER_O = 'CERT_ISSUER_O'
    CERT_ISSUER_OU = 'CERT_ISSUER_OU'
    CERT_ISSUER_L = 'CERT_ISSUER_L'
    CERT_ISSUER_P = 'CERT_ISSUER_P'
    CERT_ISSUER_SA = 'CERT_ISSUER_SA'
    CERT_ISSUER_PC = 'CERT_ISSUER_PC'
    CT_STATE = 'CT_STATE'
    LIMIT_RATE = 'LIMIT_RATE'
    BURST_SIZE = 'BURST_SIZE'


class Op1(Enum):
    field__ = '=='
    field___1 = '!='
    field_ = '<'
    field__1 = '>'
    field___2 = '<='
    field___3 = '>='


class RateUnit(Enum):
    PACKETS_PER_SECOND = 'PACKETS_PER_SECOND'
    PACKETS_PER_MINUTE = 'PACKETS_PER_MINUTE'
    PACKETS_PER_HOUR = 'PACKETS_PER_HOUR'
    PACKETS_PER_DAY = 'PACKETS_PER_DAY'
    PACKETS_PER_WEEK = 'PACKETS_PER_WEEK'
    BYTES_PER_SECOND = 'BYTES_PER_SECOND'
    KBYTES_PER_SECOND = 'KBYTES_PER_SECOND'
    MBYTES_PER_SECOND = 'MBYTES_PER_SECOND'


class BurstUnit(Enum):
    PACKETS = 'PACKETS'
    BYTES = 'BYTES'
    KBYTES = 'KBYTES'
    MBYTES = 'MBYTES'


class GroupSelector(Enum):
    IP_PROTOCOL = 'IP_PROTOCOL'
    SOURCE_ADDRESS = 'SOURCE_ADDRESS'
    DESTINATION_ADDRESS = 'DESTINATION_ADDRESS'
    SOURCE_ADDRESS_V6 = 'SOURCE_ADDRESS_V6'
    DESTINATION_ADDRESS_V6 = 'DESTINATION_ADDRESS_V6'
    SOURCE_PORT = 'SOURCE_PORT'
    DESTINATION_PORT = 'DESTINATION_PORT'


class RuleCondition2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition3(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition4(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition5(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition6(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition7(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition8(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition9(RuleCondition1, RuleCondition2):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Type9
    value: str
    op: Optional[Op1] = None
    rate_unit: Optional[RateUnit] = None
    burst_unit: Optional[BurstUnit] = None
    group_selector: Optional[GroupSelector] = None


class RuleCondition(
    RootModel[
        Union[
            RuleCondition3,
            RuleCondition4,
            RuleCondition5,
            RuleCondition6,
            RuleCondition7,
            RuleCondition8,
            RuleCondition9,
        ]
    ]
):
    root: Union[
        RuleCondition3,
        RuleCondition4,
        RuleCondition5,
        RuleCondition6,
        RuleCondition7,
        RuleCondition8,
        RuleCondition9,
    ] = Field(..., description='A rule condition')


class Rule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ruleId: conint(ge=1) = Field(..., description='The rule ID')
    enabled: Optional[bool] = Field(
        None, description='True if rule is enabled, False otherwise'
    )
    description: Optional[str] = Field(None, description='The human description')
    conditions: Optional[
        List[
            Union[
                RuleCondition3,
                RuleCondition4,
                RuleCondition5,
                RuleCondition6,
                RuleCondition7,
                RuleCondition8,
                RuleCondition9,
            ]
        ]
    ] = None
    action: Optional[RuleAction] = None
    readOnly: Optional[bool] = Field(
        None, description='True if read only, False otherwise'
    )


class Action2(RuleAction):
    type: Optional[Type6] = None


class Rule2(Rule):
    action: Optional[Action2] = None


class Chain(BaseModel):
    name: str = Field(..., description='The name of the chain')
    description: Optional[str] = Field(None, description='The human description')
    hook: Optional[Hook] = Field(
        None, description='The netfilter hook, only applies to base chains'
    )
    priority: Optional[int] = Field(
        None, description='The netfilter priority, only applies to base chains'
    )
    base: Optional[bool] = Field(
        None, description='True if base chain, False otherwise'
    )
    editable: Optional[bool] = Field(
        None, description='True if chain is editable, False otherwise'
    )
    rules: List[Rule]


class Action1(RuleAction):
    type: Optional[Type4] = None


class Rule1(Rule):
    action: Optional[Action1] = None


class Chain1(Chain):
    rules: Optional[List[Rule1]] = None


class Table(BaseModel):
    name: str = Field(..., description='The name of the table')
    family: Family = Field(..., description='The family of the table')
    chain_type: Optional[ChainType] = Field(
        None, description='The type of chains in this table'
    )
    chains: List[Chain]
    description: Optional[str] = Field(None, description='The human description')


class Action(RuleAction):
    type: Optional[Type4] = None


class RuleModel(Rule):
    action: Optional[Action] = None


class ChainModel(Chain):
    rules: Optional[List[RuleModel]] = None


class AccessTable(Table):
    chains: Optional[List[ChainModel]] = None


class StaticDhcpEntry(BaseModel):
    address: str = Field(..., description='IP Address to assign to the device')
    macAddress: str = Field(..., description='The MAC address of the device')
    description: Optional[str] = Field(None, description='The human description')


class LocalDnsServer(BaseModel):
    domain: str = Field(..., description='A local domain')
    localServer: str = Field(..., description='The IP of a local DNS server')
    description: Optional[str] = Field(None, description='The human description')


class StaticDnsEntry(BaseModel):
    address: str = Field(..., description='IP Address to map')
    name: str = Field(..., description='The name to map')
    description: Optional[str] = Field(None, description='The human description')


class AccountCredentials(BaseModel):
    username: Optional[str] = Field(None, description='The username')
    email: Optional[str] = Field(None, description='This accounts email address')
    authorizedKeys: Optional[str] = Field(None, description='SSH authorized keys')
    passwordCleartext: Optional[str] = Field(
        None,
        description='The cleartext password - this should not be saved in the settings file',
    )
    passwordHashMD5: Optional[str] = Field(
        None,
        description='The hash of the password as it would appear in /etc/shadow (MD5 salted)',
    )
    passwordHashSHA256: Optional[str] = Field(
        None,
        description='The hash of the password as it would appear in /etc/shadow (SHA256 salted)',
    )
    passwordHashSHA512: Optional[str] = Field(
        None,
        description='The hash of the password as it would appear in /etc/shadow (SHA512 salted)',
    )


class WidgetSettings(BaseModel):
    name: Optional[str] = Field(None, description='The name of the report')
    interval: Optional[int] = Field(
        None, description='The refresh interval (in seconds)'
    )


class Type17(Enum):
    SPECIFIC_WAN = 'SPECIFIC_WAN'
    BEST_OF = 'BEST_OF'
    BALANCE = 'BALANCE'


class BestOfMetric(Enum):
    LOWEST_LATENCY = 'LOWEST_LATENCY'
    HIGHEST_AVAILABLE_BANDWIDTH = 'HIGHEST_AVAILABLE_BANDWIDTH'
    LOWEST_JITTER = 'LOWEST_JITTER'
    LOWEST_PACKET_LOSS = 'LOWEST_PACKET_LOSS'


class BalanceAlgorithm(Enum):
    WEIGHTED = 'WEIGHTED'
    LATENCY = 'LATENCY'
    AVAILABLE_BANDWIDTH = 'AVAILABLE_BANDWIDTH'
    BANDWIDTH = 'BANDWIDTH'


class WanInterface(BaseModel):
    interfaceId: int = Field(..., description='The interfaceId of the interface')
    weight: Optional[conint(ge=1, le=10000)] = Field(
        None, description='The static balance weight for this interface'
    )


class Type18(Enum):
    ATTRIBUTE = 'ATTRIBUTE'
    METRIC = 'METRIC'
    CONNECTIVITY = 'CONNECTIVITY'


class Attribute(Enum):
    VPN = 'VPN'
    NAME = 'NAME'


class Metric(Enum):
    LATENCY = 'LATENCY'
    AVAILABLE_BANDWIDTH = 'AVAILABLE_BANDWIDTH'
    JITTER = 'JITTER'
    PACKET_LOSS = 'PACKET_LOSS'


class MetricOp(Enum):
    field_ = '<'
    field__1 = '>'
    field__ = '<='
    field___1 = '>='


class ConnectivityTestType(Enum):
    PING = 'PING'
    ARP = 'ARP'
    DNS = 'DNS'
    HTTP = 'HTTP'


class WanCriterion(BaseModel):
    type: Type18 = Field(..., description='The policy type')
    attribute: Optional[Attribute] = Field(None, description='An interface attribute')
    name_contains: Optional[str] = Field(
        None,
        description='The string to search for in interface names for the NAME attribute criterion',
    )
    metric: Optional[Metric] = Field(None, description='An interface metric')
    metric_value: Optional[int] = Field(
        None, description='The value associated with the interface metric'
    )
    metric_op: Optional[MetricOp] = None
    connectivityTestType: Optional[ConnectivityTestType] = Field(
        None, description='The type of connectivity test'
    )
    connectivityTestInterval: Optional[int] = Field(
        None, description='The connectivity test interval in seconds'
    )
    connectivityTestTimeout: Optional[int] = Field(
        None, description='The connectivity test timeout in seconds'
    )
    connectivityTestFailureThreshold: Optional[int] = Field(
        None,
        description='The number of test failures (out of 10) that represents an interface failure',
    )
    connectivityTestTarget: Optional[str] = Field(
        None, description='IP/host address to test'
    )


class DiscoveryPluginSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Optional[str] = Field(None, description='The discovery collector type')
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the individual collector'
    )
    autoInterval: Optional[float] = Field(
        None, description='The autoscan interval to run this collector on'
    )


class Actions1(BaseModel):
    pass


class Actions(BaseModel):
    block: Optional[List[str]] = None
    log: Optional[List[str]] = None


class GeoipNetworkSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: Optional[str] = Field(
        None, description='CIDR network to bypass from fencing'
    )
    description: Optional[str] = Field(None, description='Description of the network')


class Authentication(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    shared_secret: Optional[str] = Field(
        None, description='The shared secret value for auth'
    )
    type: Optional[str] = Field(
        None, description='the type of authentication configured'
    )


class IpsecEncryption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    encryption: Optional[str] = Field(None, description='The encryption type')
    group: Optional[str] = Field(None, description='The encryption group information')
    hash: Optional[str] = Field(None, description='The hash type information')


class NetworkDefinition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    network: Optional[str] = Field(None, description='the network address')
    prefix: Optional[float] = Field(None, description='The network CIDR prefix range')


class StaticRouteItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='True if static route is enabled, false otherwise'
    )
    description: Optional[str] = Field(
        None, description='Description of the static route'
    )
    interfaceId: Optional[float] = Field(
        None, description='The interface ID to link the static route with'
    )
    network: Optional[str] = Field(
        None, description='Static route network destination information'
    )
    nextHop: Optional[str] = Field(
        None, description='The nexthop/gateway of the static route definition'
    )
    metric: Optional[float] = Field(
        None, description='Specifies the route metric to use'
    )


class ThreatpreventionBypassItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    host: Optional[str] = Field(
        None, description='CIDR network to bypass from threat prevention'
    )
    description: Optional[str] = Field(None, description='Description of the network')


class UriTranslations(BaseModel):
    uri: Optional[str] = Field(None, description='The URI to match for')
    host: Optional[str] = Field(
        None, description='The host to replace the URI with during URI translation'
    )


class WebfilterCategories(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description='True if webfilter category is being filtered/blocked, false otherwise',
    )
    flagged: Optional[bool] = Field(
        None, description='True if webfilter category is being flagged, false otherwise'
    )
    id: Optional[float] = Field(
        None, description='Unique identifier of the webfilter category'
    )
    logged: Optional[bool] = Field(
        None,
        description='True if webfilter category is being reported, false otherwise',
    )


class WebfilterListItem(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='True if list item filtered/blocked, false otherwise'
    )
    description: Optional[str] = Field(None, description='Description of the list item')
    exact: Optional[bool] = Field(
        None,
        description='True if list item name is being exact matched, otherwise wildcard match the name',
    )
    flagged: Optional[bool] = Field(
        None, description='True if list item is being flagged, false otherwise'
    )
    name: Optional[str] = Field(None, description='The list item value to match on')
    logged: Optional[bool] = Field(
        None, description='True if list item is being reported, false otherwise'
    )


class ApplicationControlActions(BaseModel):
    reject: Optional[List[str]] = None
    block: Optional[List[str]] = None
    flag: Optional[List[str]] = None
    log: Optional[List[str]] = None


class Type19(Enum):
    CLIENT_ADDRESS = 'CLIENT_ADDRESS'
    CLIENT_PORT = 'CLIENT_PORT'
    SERVER_ADDRESS = 'SERVER_ADDRESS'
    SERVER_PORT = 'SERVER_PORT'
    PROTOCOL_TYPE = 'PROTOCOL_TYPE'


class ApplicationControlCustomRulesCondition(BaseModel):
    type: Optional[Type19] = None
    value: Optional[str] = None
    op: Optional[Op1] = None


class Type20(Enum):
    CLIENT_ADDRESS = 'CLIENT_ADDRESS'
    CLIENT_PORT = 'CLIENT_PORT'
    DAY_OF_WEEK = 'DAY_OF_WEEK'
    DEST_ADDRESS = 'DEST_ADDRESS'
    DESTINATION_INTERFACE_TYPE = 'DESTINATION_INTERFACE_TYPE'
    GEOIP_LOCATION = 'GEOIP_LOCATION'
    INTERFACE = 'INTERFACE'
    SERVER_ADDRESS = 'SERVER_ADDRESS'
    SERVER_PORT = 'SERVER_PORT'
    SERVICE_ENDPOINT = 'SERVICE_ENDPOINT'
    SERVICE_ENDPOINT_CLIENT = 'SERVICE_ENDPOINT_CLIENT'
    SERVICE_ENDPOINT_SERVER = 'SERVICE_ENDPOINT_SERVER'
    SOURCE_ADDRESS = 'SOURCE_ADDRESS'
    SOURCE_INTERFACE_TYPE = 'SOURCE_INTERFACE_TYPE'
    PROTOCOL_TYPE = 'PROTOCOL_TYPE'
    TIME_OF_DAY = 'TIME_OF_DAY'
    VLAN_ID = 'VLAN_ID'
    APPLICATION = 'APPLICATION'
    CLIENT_APPLICATION = 'CLIENT_APPLICATION'
    SERVER_APPLICATION = 'SERVER_APPLICATION'


class Op10(Enum):
    field__ = '=='
    field___1 = '!='
    field_ = '<'
    field__1 = '>'
    field___2 = '<='
    field___3 = '>='
    in_ = 'in'
    match = 'match'


class PolicyManagerCriterion(BaseModel):
    type: Optional[Type20] = None
    op: Optional[Op10] = None
    object: Optional[Union[Any, List[Any]]] = None


class Type21(Enum):
    mfw_rule_geoip = 'mfw-rule-geoip'


class Type22(Enum):
    mfw_rule_applicationcontrol = 'mfw-rule-applicationcontrol'


class Type23(Enum):
    mfw_rule_wanpolicy = 'mfw-rule-wanpolicy'


class Type24(Enum):
    mfw_rule_security = 'mfw-rule-security'


class Type25(Enum):
    DnsRuleObject = 'DnsRuleObject'


class Type26(Enum):
    mfw_rule_portforward = 'mfw-rule-portforward'


class Type27(Enum):
    mfw_rule_threatprevention = 'mfw-rule-threatprevention'


class Type28(Enum):
    mfw_rule_webfilter = 'mfw-rule-webfilter'


class Type29(Enum):
    mfw_rule_captiveportal = 'mfw-rule-captiveportal'


class Type30(Enum):
    mfw_rule_shaping = 'mfw-rule-shaping'


class Type31(Enum):
    mfw_rule_nat = 'mfw-rule-nat'


class PolicyManagerCategory(Enum):
    discovery = 'discovery'
    geoip = 'geoip'
    threatprevention = 'threatprevention'
    webfilter = 'webfilter'


class PolicyManagerFilters(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class PolicyManagerFilter(BaseModel):
    operator: Optional[str] = None
    type: Optional[str] = None
    property: Optional[str] = None


class Type32(Enum):
    GeoIPLocation = 'GeoIPLocation'
    InterfaceZone = 'InterfaceZone'
    IPAddrList = 'IPAddrList'
    ServiceEndpoint = 'ServiceEndpoint'
    ConditionGroup = 'ConditionGroup'


class PolicyManagerIpspecifier(RootModel[Any]):
    root: Any


class PolicyManagerPortspecifier(RootModel[Any]):
    root: Any


class PingAnalyzerSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(None, description='Name of Ping Analyzer')
    interfaceIds: Optional[List[int]] = None
    ipv4Addresses: Optional[List[str]] = None
    ipv6Addresses: Optional[List[str]] = None
    enabled: Optional[bool] = Field(None, description='Turns a Ping Analyzer on or off')


class DynamicListsConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='True, if user want this configuration to be active.'
    )
    name: Optional[str] = Field(None, description='Name of the block list from source')
    id: Optional[str] = Field(None, description='ID of the block list from source')
    source: Optional[str] = Field(
        None, description='The source URL or the local file path'
    )
    type: Optional[str] = Field(
        None, description='Either IP or URL block list type from source'
    )
    pollingUnit: Optional[str] = Field(
        None,
        description='Tells us the interval of fetching whether its Minutes, Hours, Days or Months as a unit',
    )
    pollingTime: Optional[float] = Field(
        None,
        description='The respective value based on the selection of the PullingUnit',
    )
    skipCertCheck: Optional[bool] = Field(
        None, description='Flag to ignore certificate verification of HTTPS requests'
    )
    parsingMethod: Optional[str] = Field(
        None,
        description='The parsing method for a passed IP list. Stored as a regular expression.',
    )


class Logo(BaseModel):
    imageName: Optional[str] = None


class Type33(Enum):
    ENABLE = 'ENABLE'
    DISABLE = 'DISABLE'


class Action4(BaseModel):
    type: Optional[Type33] = None


class Type34(Enum):
    DESTINATION_ADDRESS = 'DESTINATION_ADDRESS'
    DESTINATION_ADDRESS_V6 = 'DESTINATION_ADDRESS_V6'
    DESTINATION_INTERFACE_TYPE = 'DESTINATION_INTERFACE_TYPE'
    DESTINATION_INTERFACE_ZONE = 'DESTINATION_INTERFACE_ZONE'
    DESTINATION_PORT = 'DESTINATION_PORT'
    SOURCE_ADDRESS = 'SOURCE_ADDRESS'
    SOURCE_ADDRESS_V6 = 'SOURCE_ADDRESS_V6'
    SOURCE_INTERFACE_TYPE = 'SOURCE_INTERFACE_TYPE'
    SOURCE_INTERFACE_ZONE = 'SOURCE_INTERFACE_ZONE'
    SOURCE_PORT = 'SOURCE_PORT'
    IP_PROTOCOL = 'IP_PROTOCOL'


class Op11(Enum):
    field__ = '=='
    field___1 = '!='


class CaptiveportalRulesConditions(BaseModel):
    type: Optional[Type34] = None
    value: Optional[str] = None
    op: Optional[Op11] = None


class QuotaManagerConfiguration(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    data_size: str
    period: str


class QuotaManagerExceedAction(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    default: Optional[bool] = None
    action: str


class Action5(BaseModel):
    pass


class QuotaManagerRuleAction(BaseModel):
    exceed_action_id: str
    quota_id: str
    type: str


class QuotaManagerRuleCondition(BaseModel):
    op: str
    type: str
    value: str
    proto: Optional[str] = None


class Logname(Enum):
    EMERG = 'EMERG'
    ALERT = 'ALERT'
    CRIT = 'CRIT'
    ERROR = 'ERROR'
    WARN = 'WARN'
    NOTICE = 'NOTICE'
    INFO = 'INFO'
    DEBUG = 'DEBUG'
    TRACE = 'TRACE'


class LoggerSetting1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    logname: Logname = Field(..., description='The logging level')


class LoggerSetting(RootModel[Optional[Dict[str, LoggerSetting1]]]):
    root: Optional[Dict[str, LoggerSetting1]] = Field(
        None, description='The logger settings for a package or function'
    )


class Type35(Enum):
    sqlite = 'sqlite'
    mysql = 'mysql'
    postgres = 'postgres'


class DatabaseConfigSettings(BaseModel):
    name: Optional[str] = Field(
        None, description='DB Connection name (this will be shown on UI)'
    )
    description: Optional[str] = Field(
        None, description='Additional description for the DB Connection'
    )
    id: Optional[str] = Field(None, description='UUID for Database (auto-generated)')
    type: Optional[Type35] = Field(
        None, description='Database type i.e. MySQL,postgres'
    )
    enabled: Optional[bool] = Field(
        None, description='Database Connection enabled/disabled'
    )
    db_server: Optional[str] = Field(None, description='Remote Host/Server')
    db_name: Optional[str] = Field(None, description='Name of the Database.')
    db_username: Optional[str] = Field(None, description='Username for the Database.')
    db_port: Optional[int] = Field(None, description='Database Port')
    db_password: Optional[str] = Field(
        None, description='Database password for the given user.'
    )
    db_connection_string: Optional[str] = Field(None, description='Connection String')
    default: Optional[bool] = Field(
        None, description='Flag which determines if the database is default'
    )


class Type36(Enum):
    BYPASS = 'BYPASS'


class Action6(BaseModel):
    type: Optional[Type36] = None


class Type37(Enum):
    DESTINATION_ADDRESS = 'DESTINATION_ADDRESS'
    DESTINATION_ADDRESS_V6 = 'DESTINATION_ADDRESS_V6'
    DESTINATION_INTERFACE_TYPE = 'DESTINATION_INTERFACE_TYPE'
    DESTINATION_INTERFACE_ZONE = 'DESTINATION_INTERFACE_ZONE'
    DESTINATION_PORT = 'DESTINATION_PORT'
    SOURCE_ADDRESS = 'SOURCE_ADDRESS'
    SOURCE_ADDRESS_V6 = 'SOURCE_ADDRESS_V6'
    SOURCE_INTERFACE_TYPE = 'SOURCE_INTERFACE_TYPE'
    SOURCE_INTERFACE_ZONE = 'SOURCE_INTERFACE_ZONE'
    SOURCE_PORT = 'SOURCE_PORT'
    IP_PROTOCOL = 'IP_PROTOCOL'


class BypassRulesConditions(BaseModel):
    type: Optional[Type37] = None
    value: Optional[str] = None
    op: Optional[Op11] = None
    port_protocol: Optional[str] = None


class DnsfilterBlocklist(BaseModel):
    description: Optional[str] = None
    enabled: Optional[bool] = None
    flagged: Optional[bool] = None
    logged: Optional[bool] = None
    exact: Optional[bool] = None
    name: Optional[str] = None


class AlertObject(BaseModel):
    message: str
    enabled: bool


class Action7(Enum):
    alert = 'alert'
    block = 'block'
    pass_ = 'pass'
    reject = 'reject'


class IpsRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enable/Disable the IPS rule')
    sid: Optional[int] = Field(
        None, description='The unique identifier for the IPS rule'
    )
    action: Optional[Action7] = Field(
        None, description='Action to take when the rule matches'
    )
    message: Optional[str] = Field(
        None, description='Message to log when the rule matches (optional)'
    )
    classType: Optional[str] = Field(
        None, description='Class type of the IPS rule (optional)'
    )


class IpsRuleList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(None, description='Name of the IPS rule list')
    url: Optional[str] = Field(None, description='URL to fetch the IPS rule list from')
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the IPS rule list'
    )
    local_dir: Optional[str] = Field(
        None, description='Local directory to reference the IPS rule list (optional)'
    )
    version: Optional[str] = Field(
        None, description='Version of the IPS rule list (optional)'
    )


class SwitchSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='The switch name (switch0)')
    ports: List[SwitchPort] = Field(..., description='The ports of the switch')
    vlans: List[SwitchVlan] = Field(
        ..., description='Hardware based vlans of the switch'
    )


class InterfaceSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    interfaceId: conint(ge=1) = Field(..., description='Unique interface ID')
    name: constr(min_length=1, max_length=15) = Field(
        ..., description='Human readable name'
    )
    enabled: Optional[bool] = Field(
        None, description='True if this interface is enabled, False otherwise'
    )
    device: str = Field(
        ..., description='The physical dev represented by this interface (eth0)'
    )
    wan: bool = Field(
        ...,
        description='True if interface is a WAN (internet) connected interface, False otherwise',
    )
    hidden: Optional[bool] = Field(
        None,
        description='True if this interface should be hidden from the user, False otherwise',
    )
    type: Type
    configType: ConfigType = Field(..., description='The configuration type')
    natEgress: Optional[bool] = Field(
        None,
        description='If true, NAT outbound sessions and block non-port-forwarded sessions from this interface',
    )
    natIngress: Optional[bool] = Field(
        None,
        description='If true, NAT inbound sessions and block non-port-forwarded sessions to this interface',
    )
    v4ConfigType: Optional[V4ConfigType] = Field(
        None, description='The IPv4 configuration type'
    )
    v4StaticAddress: Optional[IPv4Address] = Field(
        None, description='The IPv4 static address'
    )
    v4StaticPrefix: Optional[conint(ge=1, le=32)] = Field(
        None, description='The IPv4 static prefix (netmask)'
    )
    v4StaticGateway: Optional[IPv4Address] = Field(
        None, description='The IPv4 static gateway'
    )
    v4StaticDNS1: Optional[IPv4Address] = Field(None, description='The IPv4 DNS 1')
    v4StaticDNS2: Optional[IPv4Address] = Field(None, description='The IPv4 DNS 2')
    v4DhcpAddressOverride: Optional[IPv4Address] = Field(
        None, description='The DHCP address override'
    )
    v4DhcpPrefixOverride: Optional[conint(ge=1, le=32)] = Field(
        None, description='The DHCP prefix override'
    )
    v4DhcpGatewayOverride: Optional[IPv4Address] = Field(
        None, description='The DHCP gateway override'
    )
    v4DhcpDNS1Override: Optional[IPv4Address] = Field(
        None, description='The DHCP DNS 1 override'
    )
    v4DhcpDNS2Override: Optional[IPv4Address] = Field(
        None, description='The DHCP DNS 2 override'
    )
    v4PPPoEUsername: Optional[constr(min_length=1)] = Field(
        None, description='The PPPoE username'
    )
    v4PPPoEPassword: Optional[constr(min_length=1)] = Field(
        None, description='The PPPoE password'
    )
    v4PPPoEUsePeerDNS: Optional[bool] = Field(
        None, description='If true, use PPPoE peer DNS'
    )
    v4PPPoEOverrideDNS1: Optional[IPv4Address] = Field(
        None, description='The PPPoE DNS 1 override'
    )
    v4PPPoEOverrideDNS2: Optional[IPv4Address] = Field(
        None, description='The PPPoE DNS 2 override'
    )
    v4Aliases: Optional[List[Ipv4Alias]] = Field(
        None, description='IPv4 address aliases'
    )
    v6ConfigType: Optional[V6ConfigType] = Field(
        None, description='IPv6 configuration type'
    )
    v6StaticAddress: Optional[IPv6Address] = Field(
        None, description='The IPv6 static address'
    )
    v6StaticPrefix: Optional[conint(ge=1, le=128)] = Field(
        None, description='The IPv6 static prefix'
    )
    v6StaticGateway: Optional[IPv6Address] = Field(
        None, description='The IPv6 static gateway'
    )
    v6StaticDNS1: Optional[IPv6Address] = Field(None, description='The IPv6 DNS 1')
    v6StaticDNS2: Optional[IPv6Address] = Field(None, description='The IPv6 DNS 2')
    v6DhcpDNS1Override: Optional[IPv6Address] = Field(
        None, description='The DHCP DNS 1 override'
    )
    v6DhcpDNS2Override: Optional[IPv6Address] = Field(
        None, description='The DHCP DNS 2 override'
    )
    v6AssignHint: Optional[str] = Field(None, description='The IPv6 auto assign hint')
    v6AssignPrefix: Optional[conint(ge=1, le=128)] = Field(
        None, description='The IPv6 auto assign prefix'
    )
    v6Aliases: Optional[List[Ipv6Alias]] = Field(
        None, description='IPv6 address aliases'
    )
    routerAdvertisements: Optional[bool] = Field(
        None, description='Send router advertisements'
    )
    bridgedTo: Optional[conint(ge=1)] = Field(
        None,
        description='The interface ID that this interface is bridgedTo if this is configType == BRIDGED',
    )
    qosEnabled: Optional[bool] = Field(None, description='Enable QoS')
    downloadKbps: Optional[conint(ge=0)] = Field(
        None,
        description='The maximum download kilobit per second of this WAN interface',
    )
    uploadKbps: Optional[conint(ge=0)] = Field(
        None, description='The maximum upload kilobit per second of this WAN interface'
    )
    macaddr: Optional[str] = Field(
        None, description='The MAC address to set for the interface'
    )
    dhcpEnabled: Optional[bool] = Field(
        None, description='If true, provide DHCP on this interface'
    )
    dhcpRangeStart: Optional[IPv4Address] = Field(
        None, description='The start of the DHCP offer range'
    )
    dhcpRangeEnd: Optional[IPv4Address] = Field(
        None, description='The end of the DHCP offer range'
    )
    dhcpLeaseDuration: Optional[conint(ge=0)] = Field(
        None, description='The DHCP lease duration in seconds'
    )
    dhcpGatewayOverride: Optional[IPv4Address] = Field(
        None,
        description='The DHCP gateway to offer. If null, the local interface IP is used',
    )
    dhcpPrefixOverride: Optional[conint(ge=1, le=32)] = Field(
        None,
        description='The DHCP prefix/netmask to offer. If null, the local interface prefix is used',
    )
    dhcpDNSOverride: Optional[IPv4Address] = Field(
        None,
        description='The DHCP DNS to offer. If null, the local interface IP is used',
    )
    dhcpOptions: Optional[List[DhcpOption]] = Field(None, description='DHCP Options')
    vrrpEnabled: Optional[bool] = Field(None, description='True if VRRP is enabled')
    vrrpID: Optional[conint(ge=1, le=255)] = Field(None, description='The VRRP ID')
    vrrpPriority: Optional[conint(ge=1, le=255)] = Field(
        None, description='The VRRP priority'
    )
    vrrpV4Aliases: Optional[List[Ipv4Alias]] = Field(
        None, description='VRRP IPv4 address aliases'
    )
    vrrpTrack: Optional[List[Track]] = Field(
        None, description='VRRP Group Tracked Objects'
    )
    wirelessSsid: Optional[str] = Field(None, description='The wireless SSID')
    wirelessEncryption: Optional[WirelessEncryption] = Field(
        None, description='The wireless encryption method'
    )
    wirelessMode: Optional[WirelessMode] = Field(
        None, description='The wireless mode (AP or client)'
    )
    wirelessPassword: Optional[str] = Field(None, description='The wireless password')
    wirelessChannel: Optional[conint(ge=0)] = Field(
        None, description='The wireless channel'
    )
    wirelessThroughput: Optional[str] = Field(
        None, description='The wireless throughput mode'
    )
    openvpnConfFile: Optional[FileSettings] = None
    openvpnUsernamePasswordEnabled: Optional[bool] = Field(
        None,
        description='True if this openvpn interface requires username/password authentication',
    )
    openvpnUsername: Optional[str] = Field(
        None, description='The openvpn username if usename authentication enabled'
    )
    boundInterfaceId: Optional[str] = Field(
        None,
        description='The interfaceId of the interface that binding technologies i.e. openvpn, VLANs, Wireguard should use to connect (0 or undefined means Any WAN)',
    )
    openvpnPasswordBase64: Optional[str] = Field(
        None,
        description='The openvpn password in cleartext/base64 if username authentication if enabled',
    )
    openvpnPeerDns: Optional[bool] = Field(
        None,
        description='Enables or Disables using the Peer DNS option from the OpenVPN tunnel',
    )
    wireguardPrivateKey: Optional[str] = Field(
        None, description='The wireguard private key'
    )
    wireguardPublicKey: Optional[str] = Field(
        None, description='The wireguard public key'
    )
    wireguardAddresses: Optional[List[WireguardAddress]] = Field(
        None, description="List of WireGuard's interface IP addresses"
    )
    wireguardEditMode: Optional[WireguardEditMode] = Field(
        None, description='How this VPN is to be editied'
    )
    wireguardType: Optional[WireguardType] = Field(None, description='Type of of VPN')
    wireguardPort: Optional[int] = Field(
        None, description='The port that wireguard listens on'
    )
    wireguardPeers: Optional[List[WireguardPeer]] = Field(
        None, description='List of wireguard peers'
    )
    simNetwork: Optional[str] = Field(None, description='Sim network name')
    simApn: Optional[str] = Field(None, description='Modem access point name')
    simProfile: Optional[int] = Field(None, description='Modem profile number')
    simPin: Optional[int] = Field(None, description='Sim pin code')
    simDelay: Optional[int] = Field(
        None, description='Delay before configuring the modem on boot'
    )
    simTimeout: Optional[int] = Field(
        None, description='Time to wait while attempting to configure the connection'
    )
    simAuth: Optional[SimAuth] = Field(None, description='Sim authentication method')
    simUsername: Optional[str] = Field(None, description='Sim authentication username')
    simPassword: Optional[str] = Field(None, description='Sim authentication password')
    simMode: Optional[SimMode] = Field(None, description='Sim mode')
    simPdptype: Optional[SimPdptype] = Field(None, description='Sim connection method')
    simPlmn: Optional[int] = Field(
        None,
        description='Sim PLMN (first three digits are mmc, last three digits are mnc)',
    )
    simAutoconnect: Optional[bool] = Field(
        None, description='Enable automatic connect/reconnect'
    )
    ethAutoneg: Optional[bool] = None
    ethDuplex: Optional[EthDuplex] = Field(None, description='Duplex mode')
    ethSpeed: Optional[int] = Field(None, description='Interface speed')
    mtu: Optional[int] = Field(None, description='Interface MTU setting')
    routeMtu: Optional[bool] = Field(
        None, description='Use Route MTU Discovery to determine MTU'
    )
    vlanid: Optional[int] = Field(
        None,
        description="Software device level 8021q VLAN ID to assign to an interface - requires a parent 'boundInterfaceId'",
    )
    virtual: Optional[bool] = Field(
        None, description='Virtual interface indicator (vlan/vpn/etc.)'
    )
    wanWeight: Optional[float] = Field(
        None, description='Weight of WAN interace to use in weighted balance algorithms'
    )


class SystemSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hostName: str
    domainName: str
    httpPort: Optional[str] = None
    httpsPort: Optional[str] = None
    cloud: Optional[CloudSettings] = None
    timeZone: Optional[TimeZoneSettings] = None
    setupWizard: Optional[SetupWizardSettings] = None
    autoUpgrade: Optional[AutoSettings] = None
    autoBackup: Optional[AutoSettings] = None
    logging: Optional[Logging] = None


class ReportCondition(BaseModel):
    uniqueId: str = Field(..., description='The unique string identifier')
    name: str = Field(..., description='The name of the report')
    category: str = Field(..., description='The category of the report')
    description: str = Field(..., description='The description of the report')
    displayOrder: int = Field(..., description='The sort order for this report')
    type: Type1 = Field(..., description='The type of report/chart')
    rendering: ReportRendering
    column: Optional[str] = Field(None, description='The column to check the value')
    operator: Optional[Operator] = Field(None, description='The sql operator')
    value: Optional[str] = Field(None, description='The value to check')


class FilterTable(Table):
    chains: Optional[List[Chain1]] = None


class Chain2(Chain):
    rules: Optional[List[Rule2]] = None


class NatTable(Table):
    chains: Optional[List[Chain2]] = None


class Rule3(Rule):
    action: Optional[Action3] = None


class Chain3(Chain):
    rules: Optional[List[Rule3]] = None


class ShapingTable(Table):
    chains: Optional[List[Chain3]] = None


class FirewallSettings(BaseModel):
    tables: Optional[
        Union[
            Dict[constr(pattern=r'access'), AccessTable],
            Dict[constr(pattern=r'filter'), FilterTable],
            Dict[constr(pattern=r'nat'), NatTable],
            Dict[constr(pattern=r'port_forward'), Any],
            Dict[constr(pattern=r'shaping'), ShapingTable],
            Dict[constr(pattern=r'.{1,}'), Table],
        ]
    ] = Field(
        None,
        description='A map from the table name as the key, to the table json object',
    )


class DhcpSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    dhcpAuthoritative: Optional[bool] = Field(
        None, description='True if this is the only dhcp server on the network'
    )
    staticDhcpEntries: Optional[List[StaticDhcpEntry]] = Field(
        None, description='List of static DHCP assignements'
    )


class DnsSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    localServers: Optional[List[LocalDnsServer]] = Field(
        None, description='List of local DNS servers'
    )
    staticEntries: Optional[List[StaticDnsEntry]] = Field(
        None, description='List of static DNS assignements'
    )


class AccountsSettings(BaseModel):
    credentials: Optional[List[AccountCredentials]] = None


class DashboardSettings(BaseModel):
    widgets: Optional[List[WidgetSettings]] = None


class WanPolicy(BaseModel):
    policyId: conint(ge=1) = Field(..., description='The policy ID')
    enabled: Optional[bool] = Field(
        None, description='True if policy is enabled, False otherwise'
    )
    description: Optional[str] = Field(None, description='The human description')
    type: Type17 = Field(..., description='The policy type')
    best_of_metric: Optional[BestOfMetric] = Field(
        None, description='The metric used for best of policies'
    )
    interfaces: List[WanInterface] = Field(
        ...,
        description='The list of interfaces in the policy.  A single interface of id 0 means all wan interfaces',
    )
    balance_algorithm: Optional[BalanceAlgorithm] = Field(
        None, description='Algorithm used for balance type policies'
    )
    criteria: Optional[List[WanCriterion]] = Field(
        None, description='The list of policy interface criteria'
    )
    readOnly: Optional[bool] = Field(
        None, description='True if read only, False otherwise'
    )


class DiscoverySettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the host device discovery tool'
    )
    plugins: Optional[List[DiscoveryPluginSettings]] = None


class GeoipSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the geoip fencing service'
    )
    enabledLog: Optional[bool] = Field(
        None, description='Enable/Disable logging of the the geoip fencing results'
    )
    actions: Optional[Union[List[Actions], Actions1]] = None
    passedNetworks: Optional[List[GeoipNetworkSettings]] = None


class GatewayDefinition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gateway: Optional[str] = Field(
        None, description='gateway address information for local/remote gateway'
    )
    networks: Optional[List[NetworkDefinition]] = None


class RouteSettings(RootModel[List[StaticRouteItem]]):
    root: List[StaticRouteItem] = Field(..., description='Static route entries')


class ThreatpreventionSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the threat prevention service'
    )
    redirect: Optional[bool] = Field(
        None, description='Enable/Disable redirection to block page'
    )
    sensitivity: Optional[float] = Field(
        None,
        description='Threat Prevention sensitivity level, block everything above this threat level',
    )
    passList: Optional[List[ThreatpreventionBypassItem]] = None


class Uris(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uriTranslations: Optional[List[UriTranslations]] = None


class WebfilterSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='True if webfilter is enabled, false otherwise'
    )
    categories: Optional[List[WebfilterCategories]] = None
    blockList: Optional[List[WebfilterListItem]] = None
    passList: Optional[List[WebfilterListItem]] = None


class ApplicationControlCustomRules(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    category: Optional[str] = None
    conditions: Optional[List[List[ApplicationControlCustomRulesCondition]]] = None
    action: Optional[str] = None


class PolicyManagerConfiguration(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    category: Optional[List[PolicyManagerCategory]] = None


class PolicyManagerObject(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None


class PolicyManagerObjectGroup(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    items: List[str]


class PolicyManagerCondition(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    conditions: Optional[List[PolicyManagerCriterion]] = None


class PolicyManagerConditionGroup(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    items: List[str]


class PolicyManagerRule1(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type21] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule2(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type22] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule3(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type23] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule4(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type24] = None
    conditions: Optional[List[str]] = None


class PolicyManagerRule5(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type25] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule6(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type26] = None
    conditions: Optional[List[str]] = None
    dnat_address: Optional[str] = None
    dnat_port: Optional[int] = None


class PolicyManagerRule7(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type27] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule8(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type28] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule9(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type29] = None
    conditions: Optional[List[str]] = None
    configuration_id: Optional[str] = None


class PolicyManagerRule10(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type30] = None
    conditions: Optional[List[str]] = None
    priority: Optional[int] = None


class PolicyManagerRule11(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    type: Optional[Type31] = None
    conditions: Optional[List[str]] = None
    snat_address: Optional[str] = None


class PolicyManagerRule(
    RootModel[
        Union[
            PolicyManagerRule1,
            PolicyManagerRule2,
            PolicyManagerRule3,
            PolicyManagerRule4,
            PolicyManagerRule5,
            PolicyManagerRule6,
            PolicyManagerRule7,
            PolicyManagerRule8,
            PolicyManagerRule9,
            PolicyManagerRule10,
            PolicyManagerRule11,
        ]
    ]
):
    root: Union[
        PolicyManagerRule1,
        PolicyManagerRule2,
        PolicyManagerRule3,
        PolicyManagerRule4,
        PolicyManagerRule5,
        PolicyManagerRule6,
        PolicyManagerRule7,
        PolicyManagerRule8,
        PolicyManagerRule9,
        PolicyManagerRule10,
        PolicyManagerRule11,
    ]


class PolicyManagerPolicy(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    conditions: Optional[List[str]] = None
    rule: Optional[List[str]] = None


class PolicyManagerGroup(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    type: Type32
    choice: Optional[Union[PolicyManagerConditionGroup, List[Any]]] = None


class StatsSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    pingAnalyzers: Optional[List[PingAnalyzerSettings]] = None


class DynamicListsSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='enables or disables the entire dynamic blocklist feature'
    )
    configurations: Optional[List[DynamicListsConfiguration]] = None


class CaptiveportalRules(BaseModel):
    description: Optional[str] = None
    enabled: Optional[bool] = None
    ruleId: Optional[str] = None
    conditions: Optional[List[CaptiveportalRulesConditions]] = None
    action: Optional[Action4] = None


class QuotaManagerRule(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    enabled: Optional[bool] = None
    action: Optional[Union[List[QuotaManagerRuleAction], Action5]] = None
    conditions: Optional[List[QuotaManagerRuleCondition]] = None


class Logger(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    alertd: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )
    cls: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )
    discoverd: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )
    packetd: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )
    reportd: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )
    restd: Dict[str, LoggerSetting1] = Field(
        ..., description='The logger settings for a package or function'
    )


class BypassRules(BaseModel):
    description: Optional[str] = None
    enabled: Optional[bool] = None
    ruleId: Optional[str] = None
    conditions: Optional[List[BypassRulesConditions]] = None
    log: Optional[str] = None
    action: Optional[Action6] = None


class DnsfilterSettings(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the dns filter service'
    )
    blockList: Optional[List[DnsfilterBlocklist]] = None


class IpsSettings(BaseModel):
    enabled: Optional[bool] = Field(None, description='Is plugin enabled')
    enabled_ips: Optional[bool] = Field(None, description='Is IPS enabled')
    rules: Optional[List[IpsRule]] = Field(
        None, description='List of IPS rules used to override the default rules'
    )
    ruleLists: Optional[List[IpsRuleList]] = Field(
        None, description='List of IPS rule list sources'
    )


class NetworkSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    interfaces: Optional[List[InterfaceSettings]] = None
    devices: Optional[List[DeviceSettings]] = None
    switches: Optional[List[SwitchSettings]] = None


class ReportEntry(BaseModel):
    uniqueId: str = Field(..., description='The unique string identifier')
    name: str = Field(..., description='The name of the report')
    category: str = Field(..., description='The category of the report')
    description: str = Field(..., description='The description of the report')
    displayOrder: int = Field(..., description='The sort order for this report')
    readOnly: Optional[bool] = Field(
        None, description='True if read only, False otherwise'
    )
    type: Type1 = Field(..., description='The type of report/chart')
    table: Optional[str] = Field(None, description='The table the report queries')
    tables: Optional[List[str]] = Field(
        None,
        description='A list of tables joined if this is a join. This is used by the UI',
    )
    conditions: Optional[List[ReportCondition]] = None
    columnDisambiguation: Optional[List[Any]] = Field(
        None,
        description='This list of string->string map is a way to disambiguate column names for joined tables (ie time_stamp > a.time_stamp)',
    )
    userConditions: Optional[List[ReportCondition]] = None
    queryCategories: Optional[ReportQueryCategories] = None
    queryText: Optional[ReportQueryText] = None
    querySeries: Optional[ReportQuerySeries] = None
    queryEvents: Optional[ReportQueryEvents] = None
    rendering: ReportRendering


class WanSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    policy_chains: Optional[List[Chain]] = None
    policies: Optional[List[WanPolicy]] = None


class IpsecServerSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Enable/Disable the geoip fencing service'
    )
    debug: Optional[float] = Field(
        None, description='Enable/Disable ipsec server debug logs'
    )
    authentication: Optional[Authentication] = Field(
        None, description='authentication definition'
    )
    phase1: Optional[List[IpsecEncryption]] = None
    phase2: Optional[List[IpsecEncryption]] = None
    local: Optional[List[GatewayDefinition]] = None
    remote: Optional[List[GatewayDefinition]] = None


class ApplicationControlSettings(BaseModel):
    enabled: Optional[bool] = None
    cloud_classification: Optional[bool] = None
    custom_rules: Optional[List[ApplicationControlCustomRules]] = None
    actions: Optional[List[ApplicationControlActions]] = None


class PolicyManagerSettings(BaseModel):
    enabled: Optional[bool] = None
    configurations: List[PolicyManagerConfiguration]
    objects: List[PolicyManagerObject]
    object_groups: List[PolicyManagerObjectGroup]
    conditions: List[PolicyManagerCondition]
    condition_groups: Optional[List[PolicyManagerConditionGroup]] = None
    rules: List[
        Union[
            PolicyManagerRule1,
            PolicyManagerRule2,
            PolicyManagerRule3,
            PolicyManagerRule4,
            PolicyManagerRule5,
            PolicyManagerRule6,
            PolicyManagerRule7,
            PolicyManagerRule8,
            PolicyManagerRule9,
            PolicyManagerRule10,
            PolicyManagerRule11,
        ]
    ]
    policies: List[PolicyManagerPolicy]


class CaptiveportalSettings(BaseModel):
    enabled: Optional[bool] = None
    acceptText: Optional[str] = None
    acceptButtonText: Optional[str] = None
    messageHeading: Optional[str] = None
    messageText: Optional[str] = None
    welcomeText: Optional[str] = None
    logo: Optional[Logo] = None
    timeoutValue: Optional[float] = None
    timeoutPeriod: Optional[str] = None
    pageTitle: Optional[str] = None
    rules: Optional[List[CaptiveportalRules]] = None


class QuotaManagerSettings(BaseModel):
    enabled: Optional[bool] = None
    configurations: List[QuotaManagerConfiguration]
    exceed_actions: List[QuotaManagerExceedAction]
    rules: List[QuotaManagerRule]


class BypassSettings(BaseModel):
    rules: Optional[List[BypassRules]] = None


class ReportsSettings(BaseModel):
    entries: Optional[List[ReportEntry]] = None


class V1Config(BaseModel):
    version: conint(ge=1)
    network: NetworkSettings
    system: SystemSettings
    reports: Optional[ReportsSettings] = None
    firewall: Optional[FirewallSettings] = None
    dhcp: Optional[DhcpSettings] = None
    dns: Optional[DnsSettings] = None
    accounts: Optional[AccountsSettings] = None
    dashboard: Optional[DashboardSettings] = None
    files: Optional[Any] = None
    wan: Optional[WanSettings] = None
    discovery: Optional[DiscoverySettings] = None
    geoip: Optional[GeoipSettings] = None
    ipsec: Optional[IpsecServerSettings] = None
    routes: Optional[Any] = None
    threatprevention: Optional[ThreatpreventionSettings] = None
    uris: Optional[Any] = None
    webfilter: Optional[WebfilterSettings] = None
    application_control: Optional[ApplicationControlSettings] = None
    policy_manager: Optional[PolicyManagerSettings] = None
    stats: Optional[StatsSettings] = None
    dynamic_lists: Optional[DynamicListsSettings] = None
    captive_portal: Optional[CaptiveportalSettings] = None
    quota_manager: Optional[QuotaManagerSettings] = None
    logger: Optional[Logger] = None
    databases: Optional[List[DatabaseConfigSettings]] = Field(
        None, description='Database settings'
    )
    bypass: Optional[BypassSettings] = None
    dns_filter: Optional[DnsfilterSettings] = None
    alerts: Optional[List[AlertObject]] = Field(
        None, description='alerts configuration'
    )
    ips: Optional[IpsSettings] = None
